
<html>
<head>
  <meta charset="utf-8"/>
  <title>一起来看 RxJs
  </title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/><meta name="description" content="更新日志 2018-05-26 校正 2016-12-03 第一版翻译  过去你错过的 Reactive Programming 的简介你好奇于这名为Reactive Programming(反应式编程)的新事物, 更确切地说，你想了解它各种不同的实现(比如 Rx*, Bacon.js, RAC 以及其它各种各样的框架或库) 学习它比较困难, 因为比较缺好的学习材料(译者注: 原文写就时, RxJ">
<meta property="og:type" content="article">
<meta property="og:title" content="一起来看 RxJs">
<meta property="og:url" content="http://blog-next.chenlei.me/2016/12/03/lets-learn-rxjs/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="更新日志 2018-05-26 校正 2016-12-03 第一版翻译  过去你错过的 Reactive Programming 的简介你好奇于这名为Reactive Programming(反应式编程)的新事物, 更确切地说，你想了解它各种不同的实现(比如 Rx*, Bacon.js, RAC 以及其它各种各样的框架或库) 学习它比较困难, 因为比较缺好的学习材料(译者注: 原文写就时, RxJ">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://i.imgur.com/cL4MOsS.png">
<meta property="og:image" content="http://i.imgur.com/HMGWNO5.png">
<meta property="og:image" content="http://i.imgur.com/eAlNb0j.png">
<meta property="og:image" content="http://i.imgur.com/HHnmlac.png">
<meta property="og:image" content="http://i.imgur.com/Hi3zNzJ.png">
<meta property="og:image" content="http://i.imgur.com/AIimQ8C.jpg">
<meta property="article:published_time" content="2016-12-03T12:47:36.000Z">
<meta property="article:modified_time" content="2021-10-08T12:17:07.084Z">
<meta property="article:author" content="Richardo">
<meta property="article:tag" content="翻译">
<meta property="article:tag" content="rxjs">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://i.imgur.com/cL4MOsS.png">
  <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml"/>
  <link rel="icon" href="/favicon.png"/>
  <link rel="stylesheet" href="//w3cbaymax.oss-cn-shanghai.aliyuncs.com/felib/fonts/font-awesome/4.7.0/css/font-awesome.min.css"/>
  <link rel="stylesheet" href="/css/style.css?t=1633703991201"/>
<meta name="generator" content="Hexo 5.4.0"></head>
  <body>
    <div id="container">
      <div id="wrap">
<header id="header">
  <div id="banner" style="background-image: url(&quot;/assets/lets-learn-rxjs/zhanghan.jpg&quot;)"></div>
  <div class="outer" id="header-outer">
    <div class="inner" id="header-title">
      <h1 id="logo-wrap"><a href="/" id="logo">RAY</a></h1>
      <h2 id="subtitle-wrap"><a href="/" id="subtitle"><span role="text">在平坦的路面上曲折前行</span></a></h2>
    </div>
    <div class="inner" id="header-inner">
      <nav id="main-nav"><a class="nav-icon" id="main-nav-toggle"></a><a class="main-nav-link" href="/">首页</a><a class="main-nav-link" href="/archives">归档</a><a class="main-nav-link" href="/cv">简历</a>
      </nav>
      <div id="search-form-wrap"><form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://blog-next.chenlei.me"></form>
      </div>
    </div>
  </div>
</header>
        <div class="outer">
          <section id="main">
<article class="article article-typepost" id="post-lets-learn-rxjs" itemscope="itemscope" itemprop="blogPost">
  <div class="article-meta"><a class="article-date" href="/2016/12/03/lets-learn-rxjs/">
  <time datetime="2016-12-03T12:47:36.000Z" itemprop="datePublished">2016-12-03
  </time></a>
  </div>
  <div class="article-inner">
    <header class="article-header">
<div class="flex-v-center-j-between">
  <h1 class="article-title" itemprop="name">一起来看 RxJs
  </h1><span class="article-serie-prefix mr-sm">翻译</span>
</div>
    </header>
    <div class="article-entry" itemprop="articleBody"><h2 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h2><ul>
<li>2018-05-26 校正</li>
<li>2016-12-03 第一版翻译</li>
</ul>
<h2 id="过去你错过的-Reactive-Programming-的简介"><a href="#过去你错过的-Reactive-Programming-的简介" class="headerlink" title="过去你错过的 Reactive Programming 的简介"></a>过去你错过的 Reactive Programming 的简介</h2><p>你好奇于这名为Reactive Programming(反应式编程)的新事物, 更确切地说，你想了解它各种不同的实现(比如 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a>, <a target="_blank" rel="noopener" href="http://baconjs.github.io/">Bacon.js</a>, RAC 以及其它各种各样的框架或库)</p>
<p>学习它比较困难, 因为比较缺好的学习材料(译者注: 原文写就时, RxJs 还在 v4 版本, 彼时社区对 RxJs 的探索还不够完善). 我在开始学习的时候, 试图找过教程, 不过能找到的实践指南屈指可数, 而且这些教程只不过隔靴搔痒, 并不能帮助你做真正了解 RxJs 的基本概念. 如果你想要理解其中一些函数, 往往代码库自带的文档帮不到你. 说白了, 你能一下看懂下面这种文档么:</p>
<blockquote>
<p><strong>Rx.Observable.prototype.flatMapLatest(selector, [thisArg])</strong></p>
</blockquote>
<blockquote>
<p>按照将元素的索引合并的方法, 把一个 “observable 队列 “ 中的作为一个新的队列加入到 “observable 队列的队列” 中, 然后把 “observable 队列的队列” 中的一个 “observable 队列” 转换成一个 “仅从最近的 ‘observable 队列’ 产生的值构成的一个新队列.”</p>
</blockquote>
<p>这是都是什么鬼?</p>
<p>我读了两本书, 一本只是画了个大致的蓝图, 另一本则是一节一节教你 “如何使用 Reactive Libarary” . 最后我以一种艰难的方式来学习 Reactive Programming: 一遍写, 一遍理解. 在我就职于 <a target="_blank" rel="noopener" href="https://www.futurice.com/">Futurice</a> 的时候, 我第一次在一个真实的项目中使用它, 我在遇到问题时, 得到了来自<a target="_blank" rel="noopener" href="http://blog.futurice.com/top-7-tips-for-rxjava-on-android">同事的支持</a>.</p>
<p>学习中最困难的地方是 <strong>以 Reactive(反应式) 的方式思考</strong>. 这意思就是, 放下你以往熟悉的编程中的命令式和状态化思维习惯, 鼓励自己以一种不同的范式去思考. 至今我还没在网上找到任何这方面的指南, 而我认为世界上应该有一个说明如何以 Reactive(反应式) 的方式思考的教程, 这样你才知道要如何开始使用它. 在阅读完本文后之后. 请继续阅读代码库自带的文档来指引你之后的学习. 我希望, 这篇文档对你有所帮助.</p>
<h2 id="“什么是-Reactive-Programming-反应式编程-”"><a href="#“什么是-Reactive-Programming-反应式编程-”" class="headerlink" title="“什么是 Reactive Programming(反应式编程)?”"></a>“什么是 Reactive Programming(反应式编程)?”</h2><p>在网上可以找到大量对此糟糕的解释和定义. <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Reactive_programming">Wikipedia 的</a> 意料之中地泛泛而谈和过于理论化. <a target="_blank" rel="noopener" href="http://stackoverflow.com/questions/1028250/what-is-functional-reactive-programming">Stackoverflow 的</a> 圣经般的答案也绝对不适合初学者. <a target="_blank" rel="noopener" href="http://www.reactivemanifesto.org/">Reactive Manifesto</a> 听起来就像是要给你公司的项目经理或者是老板看的东西. 微软的 <a target="_blank" rel="noopener" href="https://rx.codeplex.com/">Rx 术语</a> “Rx = Observables + LINQ + Schedulers” 也读起来太繁重, 太微软了, 以至于你看完后仍然一脸懵逼. 类似于 “reactive” 和 “propagation” 的术语传达出的含义给人感觉无异于你以前用过的 MV* 框架和趁手的语言已经做到的事情. 我们现有的框架视图当然是会对数据模型做出反应, 任何的变化当然也是要冒泡的. 要不然, 什么东西都不会被渲染出来嘛.</p>
<p>所以, 让我们撇开那些无用的说辞, 尝试去了解本质.</p>
<h4 id="Reactive-programming-反应式编程-是在以异步数据流来编程"><a href="#Reactive-programming-反应式编程-是在以异步数据流来编程" class="headerlink" title="Reactive programming(反应式编程) 是在以异步数据流来编程"></a>Reactive programming(反应式编程) 是在以异步数据流来编程</h4><p>当然, 这也不是什么新东西. 事件总线或者是典型的点击事件确实就是异步事件流, 你可以对其进行 observe(观察) 或者做些别的事情. 不过, Reactive 是比之更优秀的思维模型. 你能够创建任何事物的数据流, 而不只是从点击和悬浮事件中. “流” 是普遍存在的, 一切都可能是流: 变量, 用户输入, 属性, 缓存, 数据结构等等. 比如, 想象你的 Twitter 时间线会成为点击事件同样形式的数据流.</p>
<p><strong>熟练掌握该思维模型之后, 你还会接触到一个令人惊喜的函数集, 其中包含对任何的数据流进行合并、创建或者从中筛选数据的工具.</strong> 它充分展现了 “函数式” 的魅力所在. 一个流可以作为另一个流的输入. 甚至多个流可以作为另一个流的输入. 你可以<strong>合并</strong>两个流. 你可以<strong>筛选出</strong>一个仅包含你需要的数据的另一个流. 你可以从一个流<strong>映射</strong>数据值到另一个流.</p>
<p>让我们基于 “流是 Reactive 的中心” 这个设想, 来细致地做看一下整个思维模型, 就从我们熟知的 “点击一个按钮” 事件流开始.</p>
<p><img src="http://i.imgur.com/cL4MOsS.png" alt="Click event stream"></p>
<p>每个流是一个<strong>按时序不间断的事件</strong>序列. 它可能派发出三个东西: (某种类型的)一个数值, 一个错误, 或者一个 “完成” 信号. 说到 “完成” , 举个例子, 当包含了这个按钮的当前窗口/视图关闭时, 也就是 “完成” 信号发生时.</p>
<p>我们仅能<strong>异步地</strong>捕捉到这些事件: 通过定义三种函数, 分别用来捕捉派发出的数值、错误以及 “完成” 信号. 有时候后两者可以被忽略, 你只需定义用来捕捉数值的函数. 我们把对流的 “侦听” 称为<strong>订阅(subscribing)</strong>, 我们定义的这三种函数合起来就是观察者, 流则是被观察的主体(或者叫”被观察者”). 这正是<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Observer_pattern">设计模式中的观察者模式</a>.</p>
<p>描述这种方式的另一种方式用 ASCII 字符来画个导图, 在本教程的后续的部分也能看到这种图形.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">--a---b-c---d---X---|-&gt;</span><br><span class="line"></span><br><span class="line">a, b, c, d 代表被派发出的值</span><br><span class="line">X 代表错误</span><br><span class="line">| 代表&quot;完成&quot;信号</span><br><span class="line">---&gt; 则是时间线</span><br></pre></td></tr></table></figure>

<p>这些都是是老生常谈了, 为了不让你感到无聊, 现在来点新鲜的东西: 我们将原生的点击事件流进行变换, 来创建新的点击事件流.</p>
<p>首先, 我们做一个计数流, 来指明一个按钮被点击了多少次. 在一般的 Reactive 库中, 每个流都附带了许多诸如<code>map</code>, <code>filter</code>, <code>scan</code> 等的方法. 当你调用这些方法之一(比如比如<code>clickStream.map(f)</code>)时, 它返回一个基于 clickStream 的<strong>新的流</strong>. 它没有对原生的点击事件做任何修改. 这种(不对原有流作任何修改的)特性叫做<strong>immutability(不可变性)</strong>, 而它和 Reactive(反应式) 这个概念的契合度之高好比班戟和糖浆(译者注: 班戟就是薄煎饼, 该称呼多见于中国广东地区. 此句意为 immutability 与 Reactive 两个概念高度契合). 这样的流允许我们进行链式调用, 比如<code>clickStream.map(f).scan(g)</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  clickStream: ---c----c--c----c------c--&gt;</span><br><span class="line">               vvvvv map(c becomes 1) vvvv</span><br><span class="line">               ---1----1--1----1------1--&gt;</span><br><span class="line">               vvvvvvvvv scan(+) vvvvvvvvv</span><br><span class="line">counterStream: ---1----2--3----4------5--&gt;</span><br></pre></td></tr></table></figure>

<p><code>map(f)</code> 方法根据你提供的函数<code>f</code>替换每个被派发的元素形成一个新的流. 在上例中, 我们将每次点击都映射为计数 1. <code>scan(g)</code> 方法则在内部运行<code>x = g(accumulated, current)</code>, 以某种方式连续聚合处理该流之前所有的值, 在该例子中, <code>g</code> 就是简单的加法. 然后, 一次点击发生时, <code>counterStream</code> 就派发一个点击数的总值.</p>
<p>为了展示 Reactive 真正的能力, 我们假设你想要做一个 “双击事件” 的流. 或者更厉害的, 我们假设我们想要得到一个 “三击事件流” , 甚至推广到更普遍的情况, “多击流”. 现在, 深呼吸, 想象一下按照传统的命令式和状态化思维习惯要如何完成这项工作? 我敢说那会烦死你了, 它必须包含各种各样用来保持状态的变量, 以及一些对周期性工作的处理.</p>
<p>然而, 以 Reactive 的方式, 它会非常简单. 事实上, 这个逻辑只不过是<a target="_blank" rel="noopener" href="http://jsfiddle.net/staltz/4gGgs/27/">四行代码</a>. 不过让我们现在忘掉代码.无论你是个初学者还是专家, 借助导图来思考, 才是理解和构建流最好的方法.</p>
<p><img src="http://i.imgur.com/HMGWNO5.png" alt="Multiple clicks stream"></p>
<p>图中的灰色方框是将一个流转换成另一个流的方法. 首先, 每经过 “250毫秒” 的 “事件静默” (简单地说, 这是在 <code>buffer(stream.throttle(250ms))</code> 完成的. (现在先)不必担心对这点的细节的理解, 我们主要是演示下 Reactive 的能力.), 我们就得到了一个 <strong>“点击动作” 的列表</strong>, 即, 转换的结果是<strong>一个列表</strong>的流, 而从这个流中我们应用 <code>map()</code> 将每个列表映射成对应该队列的长度的整数值. 最后, 我们使用 <code>filter(x &gt;= 2)</code> 方法忽略掉所有的 <code>1</code>. 如上: 这 3 步操作将产生我们期望的流. 我们之后可以订阅(“侦听”)它, 并按我们希望的处理方式处理流中的数据.</p>
<p>我希望你感受到了这种方式的美妙. 这个例子只是一次不过揭示了冰山一角: 你可以将相同的操作应用到不同种类的流上, 比如 API 返回的流中. 除此以外, 还有许多有效的函数.</p>
<h2 id="“为什么我应该采用反应式编程-”"><a href="#“为什么我应该采用反应式编程-”" class="headerlink" title="“为什么我应该采用反应式编程?”"></a>“为什么我应该采用反应式编程?”</h2><p>Reactive Programming (反应式编程) 提升了你代码的抽象层次, 你可以更多地关注<strong>用于定义业务逻辑</strong>的事件之间的互相依赖, 而不必写大量的细节代码来处理事件. RP(反应式编程)的代码会更简洁明了.</p>
<p>在现代网页应用和移动应用中, 这种好处是显而易见的, 这些场景下, 与数据事件关联的大量 UI 事件需要被高频地交互. 10 年前, 和 web 页面的交互只是很基础地提交一个长长的表单给后端, 然后执行一次简单的重新渲染. 在这 10 年间, App 逐渐变得更有实时性: 修改表单中的单个字段能够自动触发一次到后端的保存动作, 对某个内容的 “点赞” 需要实时反馈到其他相关的用户……</p>
<p>现今的 App 有大量的实时事件, 它们共同作用, 以带给用户良好的体验. 我们要能简洁处理这些事件的工具, 而 Reactive Programming 方式我们想要的.</p>
<h2 id="举例说明如何以反应式编程的方式思考"><a href="#举例说明如何以反应式编程的方式思考" class="headerlink" title="举例说明如何以反应式编程的方式思考"></a>举例说明如何以反应式编程的方式思考</h2><p>现在我们进入到实战. 一个真实的手把手教你如何以 RP(反应式编程) 的方式来思考的例子. 注意这里不是随处抄来的例子, 不是半吊子解释的概念. 到这篇教程结束为止, 我们会在写出真正的功能性代码的同时, 理解我们做的每个动作.</p>
<p>我选择了 <strong>JavaScript</strong> 和 <strong><a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS">RxJS</a></strong> 作为工具, 原因是, JavaScript 是当下最为人熟知的语言, 而 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 支持多数语言和平台 (<a target="_blank" rel="noopener" href="https://rx.codeplex.com/">.NET</a>, <a target="_blank" rel="noopener" href="https://github.com/Netflix/RxJava">Java</a>, <a target="_blank" rel="noopener" href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-scala">Scala</a>, <a target="_blank" rel="noopener" href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-clojure">Clojure</a>,  <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS">JavaScript</a>, <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/Rx.rb">Ruby</a>, <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxPy">Python</a>, <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxCpp">C++</a>, <a target="_blank" rel="noopener" href="https://github.com/ReactiveCocoa/ReactiveCocoa">Objective-C/Cocoa</a>, <a target="_blank" rel="noopener" href="https://github.com/Netflix/RxJava/tree/master/language-adaptors/rxjava-groovy">Groovy</a> 等等). , 无论你的工具是什么, 你可以从这篇教程中收益.</p>
<h2 id="实现一个”建议关注”盒子"><a href="#实现一个”建议关注”盒子" class="headerlink" title="实现一个”建议关注”盒子"></a>实现一个”建议关注”盒子</h2><p>在 Twitter 上, 有一个 UI 元素是建议你可以关注的其它账户.</p>
<p><img src="http://i.imgur.com/eAlNb0j.png" alt="Twitter Who to follow suggestions box"></p>
<p>我们将着重讲解如何模仿出它的核心特性:</p>
<ul>
<li>在页面启动时, 从 API 中加载账户数据, 并展示三个推荐关注者</li>
<li>在点击”刷新”时, 加载另外的三个推荐关注的账户, 形成新三行</li>
<li>在点击一个账户的 “x” 按钮时, 清除该账户并展示一个新的</li>
<li>每一行显示账户的头像和到他们主页的链接</li>
</ul>
<p>我们可以忽略其它的特性和按钮, 它们都是次要的. 另外, Twitter 最近关闭了非认证请求接口, 作为替代, 我们使用 <a target="_blank" rel="noopener" href="https://developer.github.com/v3/users/#get-all-users">Github 的 API</a> 来构建这个关注别人 UI.(注: 到本稿的最新的校正为止, github 的该接口对非认证用户启用了一段时间内访问频次限制)</p>
<p>如果你想尽早看一下完整的代码, 请点击<a target="_blank" rel="noopener" href="http://jsfiddle.net/staltz/8jFJH/48/">样例代码</a>.</p>
<h2 id="请求和回复"><a href="#请求和回复" class="headerlink" title="请求和回复"></a>请求和回复</h2><p><strong>你如何用 Rx 处理这个问题?</strong></p>
<p>首先, (几乎) <em>万物皆可为流</em> .这是 “Rx 口诀”. 让我们从最容易的特性开始: “在页面启动时, 从 API 中加载账户数据”. 这没什么难得, 只需要(1) 发一个请求, (2) 读取回复, (3) 渲染回复的中的数据. 所以我们直接把我们我们的请求当做流. 一开始就用流也许颇有”杀鸡焉用牛刀”的意味, 但为了理解, 我们需要从基本的例子开始.</p>
<p>在应用启动的时候, 我们只需要一个请求, 因此如果我们将它作为一个数据流, 它将会只有一个派发的值. 我们知道之后我们将有更多的请求, 但刚开始时只有一个.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">--a------|-&gt;</span><br><span class="line"></span><br><span class="line">其中 a 是字符串 &#x27;https://api.github.com/users&#x27;</span><br></pre></td></tr></table></figure>

<p>这是一个将请求的 URL 的流. 无论请求何时发生, 它会告诉我们两件事: 请求发生的<strong>时刻</strong>和<strong>内容</strong>. 请求执行之时就是事件派发之时, 请求的内容就是被派发的值: 一个 URL 字符串.</p>
<p>创建这样一个单值流对 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 来说非常简单, 官方对于流的术语, 是 “Observable”(可被观察者), 顾名思义它是可被观察的, 但我觉得这名字有点傻, 所以我称呼它为 <em>流</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = Rx.Observable.just(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但现在, 这只是一个字符串流, 不包含其他操作, 所以我们需要要在值被派发的时候做一些事情. 这依靠对流的<a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypesubscribeobserver--onnext-onerror-oncompleted">订阅</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">requestStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行该请求</span></span><br><span class="line">  jQuery.getJSON(requestUrl, <span class="function"><span class="keyword">function</span>(<span class="params">responseData</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意我们使用了 jQuery Ajax 回调(我们假定你应已对此<a target="_blank" rel="noopener" href="http://devdocs.io/jquery/jquery.getjson">有了解</a>)来处理请求操作的异步性. 但稍等, Rx 就是处理 <strong>异步</strong> 数据流的. 难道这个请求的回复不就是一个在未来某一刻会带回返回数据的流么? 从概念上讲, 它看起来就是的, 我们来尝试写一下.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">requestStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 执行该请求</span></span><br><span class="line">  <span class="keyword">var</span> responseStream = Rx.Observable.create(<span class="function"><span class="keyword">function</span> (<span class="params">observer</span>) </span>&#123;</span><br><span class="line">    jQuery.getJSON(requestUrl)</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123; observer.onNext(response); &#125;)</span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params">jqXHR, status, error</span>) </span>&#123; observer.onError(error); &#125;)</span><br><span class="line">    .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; observer.onCompleted(); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 对回复做一些处理</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservablecreatesubscribe"><code>Rx.Observable.create()</code></a> 所做的是自定义一个流, 这个流会通知其每个观察者(或者说其”订阅者” )有数据产生 (<code>onNext()</code>) 或发生了错误 (<code>onError()</code>). 我们需要做的仅仅是包装 jQuery Ajax Promise. <strong>稍等, 这难道是说 Promise 也是一个 Observable?</strong></p>
<!-- ![Amazed](http://www.myfacewhen.net/uploads/3324-amazed-face.gif) -->

<p>是的. Observable 就是一个 <code>Promise++</code> 对象. 在 Rx 中, 通过运行 <code>var stream = Rx.Observable.fromPromise(promise)</code> 你就可以把一个 Promise 转换成一个 Observable. 仅有的区别在于 Observables 不符合 <a target="_blank" rel="noopener" href="http://promises-aplus.github.io/promises-spec/">Promises/A+</a> 标准, 但他们在概念上是不冲突的. 一个 Promise 就是一个仅派发一个值的 Observable. Rx 流就是允许多次返回值的 Promise.</p>
<p>这个例子很可以的, 它展示了 Observable 是如何至少有 Promise 的能力. 因此如果你喜欢 Promise, 请注意 Rx Observable 也可以做到同样的事.</p>
<p>现在回到我们的例子上, 也许你已经注意到了, 我们在一个中 <code>subscribe()</code> 调用了另一个 <code>subscribe()</code>, 这有点像回调地狱. 另外, <code>responseStream</code> 的创建也依赖于 <code>requestStream</code>. 但正如前文所述, 在 Rx 中有简单的机制来最流作变换并支持从其他流创建一个新的流, 接下来我们来做这件事.</p>
<p>到目前为止, 你应该知道的对流进行变换的一个基础方法是 <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemapselector-thisarg"><code>map(f)</code></a>, 将 “流 A” 中的每一个元素作 <code>f()</code> 处理, 然后在 “流 B” 中生成一一对应的值. 如果我们这样处理我们的请求和回复流, 我们可以把请求 URL 映射到回复的 Promise (被当做是流) 中.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseMetastream = requestStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>这下我们创建了一个叫做 <em>元流</em> (流的流) 的奇怪的东西. 不必对此感到疑惑, 元流, 就是<strong>其中派发值是流</strong>的流. 你可以把它想象成 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Pointer_(computer_programming)">指针</a>: 每个被派发的值都是对其它另一个流的 <em>指针</em> . 在我们的例子中, 每个请求的 URL 都被映射为一个指针, 指向一个个包含 URL 对应的返回数据的 promise 流.</p>
<p><img src="http://i.imgur.com/HHnmlac.png" alt="Response metastream"></p>
<p>这个元流看上去有点让人迷惑, 而且对我们根本没什么用. 我们只是想要一个简单的回复流, 其中每个派发的值都应是一个 JSON 对象, 而不是一个包含 JSON 对象的 Promise. 现在来认识 <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypeflatmapselector-resultselector">Flatmap</a>: 它类似于 <code>map()</code>, 但它是把 “分支” 流中派发出的的每一项值在 “主干” 流中派发出来, 如此, 它就可以对元流进行扁平化处理.(译者注: 这里, “分支” 流指的是元流中每个被派发的值, “主干” 流是指这些值有序构成的流, 由于元流中的每个值都是流, 作者不得不用 “主干” 和 “分支” 这样的比喻来描述元流与其值的关系). 在此, Flatmap 并不是起到了”修正”的作用, 元流也并不是一个 bug, 相反, 它们正是 Rx 中处理异步回复流的工具.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> responseStream = requestStream</span><br><span class="line">  .flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p><img src="http://i.imgur.com/Hi3zNzJ.png" alt="Response stream"></p>
<p>漂亮. 因为回复流是依据请求流定义的, <strong>设想</strong>之后<br>有更多的发生在请求流中的事件, 不难想象, 就会有对应的发生在回复流中的的回复事件:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">requestStream:  --a-----b--c------------|-&gt;</span><br><span class="line">responseStream: -----A--------B-----C---|-&gt;</span><br><span class="line"></span><br><span class="line">(小写的是一个请求, 大写的是一个回复)</span><br></pre></td></tr></table></figure>

<p>现在我们终于得到了回复流, 我们就可以渲染接收到的数据</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 按你设想的方式渲染 `response` 为 DOM</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>整理一下到目前为止的代码, 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = Rx.Observable.just(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseStream = requestStream</span><br><span class="line">  .flatMap(<span class="function"><span class="keyword">function</span>(<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise(jQuery.getJSON(requestUrl));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">responseStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 按你设想的方式渲染 `response` 为 DOM</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="刷新按钮"><a href="#刷新按钮" class="headerlink" title="刷新按钮"></a>刷新按钮</h2><p>现在我们注意到, 回复中的 JSON 是一个包含 100 个用户的列表. <a target="_blank" rel="noopener" href="https://developer.github.com/v3/users/#get-all-users">Github 的 API</a> 只允许我们指定一页的偏移量, 而不能指定读取的一页中的项目数量, 所以我们只用到 3 个数据对象, 剩下的 97 个只能浪费掉. 我们暂时忽略这个问题, 之后我们会看到通过缓存回复来处理它.</p>
<p>每次刷新按钮被点击的时候, 请求流应该派发一个新的 URL, 因此我们会得到一个新的回复. 我们需要两样东西: 一个刷新按钮的点击事件流(口诀: 万物皆可成流), 并且我们需要改变请求流以依赖刷新点击流. 好在, RxJs 拥有从事件监听器产生 Observable 的工具.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.refresh&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> refreshClickStream = Rx.Observable.fromEvent(refreshButton, <span class="string">&#x27;click&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>既然刷新点击事件自身不带任何 API URL, 我们需要映射每次点击为一个实际的 URL. 现在我们将请求流改成刷新点击流, 这个流被映射为每次带有随机的偏移参数的、到 API 的请求.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>如果我直接这样写, 也不做自动化测试, 那这段代码其实有个特性没实现. 即请求不会在页面加载完时发生, 只有当刷新按钮被点击的时候才会. 但其实, 两种行为我们都需要: 刷新按钮被点击的时候的请求, 或者是页面刚打开时的请求.</p>
<p>两种场景下需要不同的流:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> startupRequestStream = Rx.Observable.just(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>但我们如何才能”合并”这两者为同一个呢? 有一个 <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypemergemaxconcurrent--other"><code>merge()</code></a> 方法. 用导图来解释的话, 它看起来像是这样的.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">stream A: ---a--------e-----o-----&gt;</span><br><span class="line">stream B: -----B---C-----D--------&gt;</span><br><span class="line">          vvvvvvvvv merge vvvvvvvvv</span><br><span class="line">          ---a-B---C--e--D--o-----&gt;</span><br></pre></td></tr></table></figure>

<p>那我们要做的事就变得很容易了:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestOnRefreshStream = refreshClickStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> startupRequestStream = Rx.Observable.just(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = Rx.Observable.merge(</span><br><span class="line">  requestOnRefreshStream, startupRequestStream</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>也有另外一种更干净的、不需要中间流的写法:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;)</span><br><span class="line">  .merge(Rx.Observable.just(<span class="string">&#x27;https://api.github.com/users&#x27;</span>));</span><br></pre></td></tr></table></figure>

<p>甚至再短、再有可读性一点:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;)</span><br><span class="line">  .startWith(<span class="string">&#x27;https://api.github.com/users&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p><a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypestartwithscheduler-args"><code>startWith()</code></a> 会照你猜的那样去工作: 给流一个起点. 无论你的输入流是怎样的, 带 <code>startWith(x)</code> 的输出流总会以 x 作为起点. 但我这样做还不够 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>, 我把 API 字符串写了两次. 一种修正的做法是把 <code>startWith()</code> 用在 <code>refreshClickStream</code> 上, 这样可以从”模拟”在页面加载时一次刷新点击事件.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>漂亮. 如果你现在回头去看我说 “有个特性没实现” 的那一段, 你应该能看出那里的代码和这里的代码的区别仅仅是多了一个 <code>startWith()</code>.</p>
<h2 id="使用流来建立”3个推荐关注者”的模型"><a href="#使用流来建立”3个推荐关注者”的模型" class="headerlink" title="使用流来建立”3个推荐关注者”的模型"></a>使用流来建立”3个推荐关注者”的模型</h2><p>到现在为止, 我们只是写完了一个发生在回复流的 <code>subscribe()</code> 中的 <em>推荐关注者</em> 的 UI. 对于刷新按钮, 我们要解决一个问题: 一旦你点击了”刷新”, 现在的三个推荐关注者仍然没有被清理. 新的推荐关注者只在请求内回复后才能拿到, 不过为了让 UI 看上去令人舒适, 我们需要在刷新按钮被点击的时候就清理当前的推荐关注者.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 清理 3 个推荐关注者的 DOM 元素</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>稍等一下. 这样做不太好, 因为这样我们就有<strong>两个</strong>会影响到推荐关注者的 DOM 元素的 subscriber (另一个是 <code>responseStream.subscribe()</code>), 这听起来不符合 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Separation_of_concerns">Separation of concerns</a>. 还记得 Reactive 口诀吗?</p>
<p><img src="http://i.imgur.com/AIimQ8C.jpg" alt="Mantra"></p>
<p>在 “万物皆可为流” 的指导下, 我们把推荐关注者构建为一个流, 其中每个派发出来的值都是一个包含了推荐关注人数据的 JSON 对象. 我们会对三个推荐关注者的数据分别做这件事. 像这样来写:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从列表中随机获取一个用户</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>至于获取另外两个用户的流, 即 <code>suggestion2Stream</code> 和 <code>suggestion3Stream</code>, 只需要把 <code>suggestion1Stream</code> 复制一遍就行了. 这不够 <a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Don't_repeat_yourself">DRY</a>, 不过对我们的教程而言, 这样能让我们的示例简单些, 同时我认为, 思考如何在这个场景下避免重复编写 <code>suggestion[N]Stream</code> 也是个好的思维练习, 就留给读者去考虑吧.</p>
<p>我们让渲染的过程发生在回复流的 subscribe() 中, 而是这样做:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 渲染第 1 个推荐关注者</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回想之前我们说的 “刷新的时候, 清理推荐关注者”, 我们可以简单地将刷新单击事件映射为 “null” 数据(它代表当前的推荐关注者为空), 并且在 <code>suggestion1Stream</code> 做这项工作, 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从列表中随机获取一个用户</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">  &#125;)</span><br><span class="line">  .merge(</span><br><span class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>在渲染的时候, 我们把 <code>null</code> 解释为 “没有数据”, 隐藏它的 UI 元素.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 隐藏第 1 个推荐关注者元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 显示第 1 个推荐关注者元素并渲染数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>整个情景是这样的:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream: ----------o--------o----&gt;</span><br><span class="line">     requestStream: -r--------r--------r----&gt;</span><br><span class="line">    responseStream: ----R---------R------R--&gt;</span><br><span class="line"> suggestion1Stream: ----s-----N---s----N-s--&gt;</span><br><span class="line"> suggestion2Stream: ----q-----N---q----N-q--&gt;</span><br><span class="line"> suggestion3Stream: ----t-----N---t----N-t--&gt;</span><br></pre></td></tr></table></figure>
<p>其中 <code>N</code> 表示 <code>null</code></p>
<p>(译者注: 注意, 当 refreshClickStream 产生新值, 即用户进行点击时, null 的产生总是立刻发生在 refreshClickStream 之后; 而 <code>refreshClickStream =&gt; requestStream =&gt; responseStream</code>, responseStream 中的值, 是发给 API 接口的异步请求的结果, 这个结果的产生往往会需要花一点时间, 必然在 null 之后, 因此可以达到 “为了让 UI 看上去令人舒适, 我们需要在刷新按钮被点击的时候就清理当前的推荐关注者” 的效果).</p>
<p>稍微完善一下, 我们会在页面启动的时候也会渲染 “空” 推荐关注人. 为此可以 <code>startWith(null)</code> 放在推荐关注人的流里:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = responseStream</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params">listUsers</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 从列表中随机获取一个用户</span></span><br><span class="line">    <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">  &#125;)</span><br><span class="line">  .merge(</span><br><span class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .startWith(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>最后我们得到的流:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">refreshClickStream: ----------o---------o----&gt;</span><br><span class="line">     requestStream: -r--------r---------r----&gt;</span><br><span class="line">    responseStream: ----R----------R------R--&gt;</span><br><span class="line"> suggestion1Stream: -N--s-----N----s----N-s--&gt;</span><br><span class="line"> suggestion2Stream: -N--q-----N----q----N-q--&gt;</span><br><span class="line"> suggestion3Stream: -N--t-----N----t----N-t--&gt;</span><br></pre></td></tr></table></figure>

<h2 id="关闭推荐关注人-并利用已缓存的回复数据"><a href="#关闭推荐关注人-并利用已缓存的回复数据" class="headerlink" title="关闭推荐关注人, 并利用已缓存的回复数据"></a>关闭推荐关注人, 并利用已缓存的回复数据</h2><p>目前还有一个特性没有实现. 每个推荐关注人格子应该有它自己的 ‘x’ 按钮来关闭它, 然后加载另一个数据来代替. 也许你的第一反应是, 用一种简单方法: 在点击关闭按钮的时候, 发起一个请求, 然后更新这个推荐人:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> close1Button = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.close1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> close1ClickStream = Rx.Observable.fromEvent(close1Button, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="comment">// close2Button 和 close3Button 重复此过程</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .merge(close1ClickStream) <span class="comment">// 把关闭按钮加在这里</span></span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure>

<p>然而这没不对. (由于 refreshClickStream 影响了所有的推荐人流, 所以)该过程会关闭并且重新加载_所有的_推荐关注人, 而不是仅更新我们想关掉的那一个. 这里有很多方式来解决这个问题, 为了玩点炫酷的, 我们会重用之前的回复数据中别的推荐人. API 返回的数据每页包含 100 个用户, 但我们每次只用到其中的 3 个, 所以我们有很多有效的刷新数据可以用, 没必要再请求新的.</p>
<p>再一次的, 让我们用流的思维来思考. 当一个 ‘close1’点击事件发生的时候, 我们使用 <code>responseStream</code>  中 <em>最近被派发的</em> 回复来从回复的用户列表中随机获取一个用户. 如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    requestStream: --r---------------&gt;</span><br><span class="line">   responseStream: ------R-----------&gt;</span><br><span class="line">close1ClickStream: ------------c-----&gt;</span><br><span class="line">suggestion1Stream: ------s-----s-----&gt;</span><br></pre></td></tr></table></figure>

<p>在 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 中, 有一个合成器方法叫做 <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md#rxobservableprototypecombinelatestargs-resultselector"><code>combineLatest</code></a>, 似乎可以完成我们想做的事情. 它把两个流 A 和 B 作为其输入, 而当其中任何一个派发值的时候, <code>combineLatest</code> 会把两者最近派发的值 <code>a</code> 和 <code>b</code> 按照 <code>c = f(x,y)</code> 的方法合并处理再输出, 其中 <code>f</code> 是你可以定义的方法. 用图来解释也许更清楚:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stream A: --a-----------e--------i--------&gt;</span><br><span class="line">stream B: -----b----c--------d-------q----&gt;</span><br><span class="line">          vvvvvvvv combineLatest(f) vvvvvvv</span><br><span class="line">          ----AB---AC--EC---ED--ID--IQ----&gt;</span><br><span class="line"></span><br><span class="line">在该例中, f 是一个转换为全大写的函数</span><br></pre></td></tr></table></figure>

<p>我们可以把 combineLatest() 用在 <code>close1ClickStream</code> 和 <code>responseStream</code> 上, 因此一旦 “关闭按钮1” 被点击(导致 <code>close1ClickStream</code> 产生新值), 我们都能得到最新的返回数据, 并在 <code>suggestion1Stream</code> 中产生一个新的值. 由于 combineLatest() 的对称性的, 任何时候, 只要 <code>responseStream</code> 派发了一个新的回复, 它也将合并最新的一次 ‘关闭按钮1被点击’ 事件来产生一个新的推荐关注人. 这个特性非常有趣, 因为它允许我们简化我们之前的 <code>suggestion1Stream</code> , 如下:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream</span><br><span class="line">  .combineLatest(responseStream,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .merge(</span><br><span class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .startWith(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>

<p>在上述思考中, 还有一点东西被遗漏. combineLatest() 使用了两个数据源中最近的数据, 但是如果这些源中的某个从未派发过任何东西, combineLatest() 就不能产生一个数据事件到输出流. 如果你再细看上面的 ASCII 图, 你会发现当第一个流派发 <code>a</code> 的时候, 不会有任何输出. 只有当第二个流派发 <code>b</code> 的时候才能产生一个输出值.</p>
<p>有几种方式来解决该问题, 我们仍然采取最简单的一种, 就是在页面启动的时候模拟一次对 ‘关闭按钮1’ 按钮的点击:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.startWith(<span class="string">&#x27;startup click&#x27;</span>) <span class="comment">// 把对&quot;关闭按钮1&quot;的点击的模拟加在这里</span></span><br><span class="line">  .combineLatest(responseStream,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;l</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .merge(</span><br><span class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .startWith(<span class="literal">null</span>);</span><br></pre></td></tr></table></figure>
<h2 id="总结整理"><a href="#总结整理" class="headerlink" title="总结整理"></a>总结整理</h2><p>现在我们的工作完成了. 完整的代码如下所示:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> refreshButton = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.refresh&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> refreshClickStream = Rx.Observable.fromEvent(refreshButton, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> closeButton1 = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;.close1&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> close1ClickStream = Rx.Observable.fromEvent(closeButton1, <span class="string">&#x27;click&#x27;</span>);</span><br><span class="line"><span class="comment">// close2 和 close3 是同样的逻辑</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> requestStream = refreshClickStream.startWith(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> randomOffset = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">500</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;https://api.github.com/users?since=&#x27;</span> + randomOffset;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> responseStream = requestStream</span><br><span class="line">  .flatMap(<span class="function"><span class="keyword">function</span> (<span class="params">requestUrl</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Rx.Observable.fromPromise($.ajax(&#123;<span class="attr">url</span>: requestUrl&#125;));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> suggestion1Stream = close1ClickStream.startWith(<span class="string">&#x27;startup click&#x27;</span>)</span><br><span class="line">  .combineLatest(responseStream,</span><br><span class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">click, listUsers</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> listUsers[<span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*listUsers.length)];</span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br><span class="line">  .merge(</span><br><span class="line">    refreshClickStream.map(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; <span class="keyword">return</span> <span class="literal">null</span>; &#125;)</span><br><span class="line">  )</span><br><span class="line">  .startWith(<span class="literal">null</span>);</span><br><span class="line"><span class="comment">// suggestion2Stream 和 suggestion3Stream 是同样的逻辑</span></span><br><span class="line"></span><br><span class="line">suggestion1Stream.subscribe(<span class="function"><span class="keyword">function</span>(<span class="params">suggestion</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (suggestion === <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="comment">// 隐藏第 1 个推荐关注者元素</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 显示第 1 个推荐关注者元素并渲染数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><strong>你可以在这里查看完整的<a target="_blank" rel="noopener" href="http://jsfiddle.net/staltz/8jFJH/48/">样例代码</a></strong></p>
<p>很惭愧, 这只是一个微小的代码示例, 但它的信息量很大: 它着重表现了, 如何<strong>对关注点进行适当的隔离</strong>, 从而对不同流进行管理, 甚至充分利用了返回数据的流. 这样的函数式风格使得代码像声明式多于像命令式: 我们并不用给出一个要执行的的结构化序列, 我们只是通过定义流之间的关系来<strong>表达系统中每件事物是什么</strong>. 举例来说, 通过 Rx, 我们告诉计算机 <em><code>suggestion1Stream</code> 就是 <code>点击关闭按钮1</code> 的流, 与最近一个API返回的（用户中随机选择的一个）的用户的流, 刷新时产生 <code>null</code> 的流, 和应用启动时产生 <code>null</code> 的流的合并流</em>.</p>
<p>回想一下那些你熟稔的流程控制的语句(比如 <code>if</code>, <code>for</code>, <code>while</code>), 以及 Javascript 应用中随处可见的基于回调的控制流. (只要你愿意, )你甚至可以在上文的 <code>subscribe()</code> 中不写 <code>if</code> 和 <code>else</code>, 而是(在 observable 上)使用 <code>filter()</code>(这一块我就不写实现细节了, 留给你作为练习). 在 Rx 中, 有很多流处理方法, 比如 <code>map</code>, <code>filter</code>, <code>scan</code>, <code>merge</code>, <code>combineLatest</code>, <code>startWith</code>, 以及非常多用于控制一个事件驱动的程序的流的方法. 这个工具集让你用更少的代码而写出更强大的效果.</p>
<h2 id="接下来还有什么"><a href="#接下来还有什么" class="headerlink" title="接下来还有什么?"></a>接下来还有什么?</h2><p>如果你愿意用 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 来做反应式编程, 请花一些时间来熟悉这个 <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/api/core/observable.md">函数列表</a>, 其中涉及如何变换, 合并和创建 Observables (被观察者). 如果你想以图形的方式理解这些方法, 可以看一下 <a target="_blank" rel="noopener" href="https://github.com/Netflix/RxJava/wiki/Creating-Observables">弹珠图解 RxJava</a>. 一旦你对理解某物有困难的时候, 试着画一画图, 基于图来思考, 看一下函数列表, 再继续思考. 以我的经验, 这样的学习流程非常有用.</p>
<p>一旦你熟悉了如何使用 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 进行变成, 理解冷热酸甜, 想吃就吃…哦不, <a target="_blank" rel="noopener" href="https://github.com/Reactive-Extensions/RxJS/blob/master/doc/gettingstarted/creating.md#cold-vs-hot-observables">冷热 Observables</a> 就很有必要了. 反正就算你跳过了这一节, 你也会回来重新看的, 勿谓言之不预也. 建议通过学习真正的函数式编程来磨练你的技巧, 并且熟悉影响各种议题, 比如”影响 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 的副作用”什么的.</p>
<p>不过, 实现了反应式编程的库并非并非只有 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a>. <a target="_blank" rel="noopener" href="http://baconjs.github.io/">Bacon.js</a> 的运行机制就很直观, 理解它不像理解 <a target="_blank" rel="noopener" href="http://www.reactivex.io/">Rx*</a> 那么难; <a target="_blank" rel="noopener" href="http://elm-lang.org/">Elm Language</a> 在特定的应用场景有很强的生命里: 它是一种会编译到 Javascript + HTML + CSS 的反应式编程<strong>语言</strong>, 它的特色在于 <a target="_blank" rel="noopener" href="http://debug.elm-lang.org/">time travelling debugger</a>. 这些都很不错.</p>
<p>Rx 在严重依赖事件的前端应用中表现优秀. 但它不只是只为客户端应用服务的, 在接近数据库的后端场景中也大有可为. 实际上, <a target="_blank" rel="noopener" href="http://techblog.netflix.com/2013/02/rxjava-netflix-api.html">RxJava 正是激活 Netflex 服务端并发能力的关键</a>. Rx 不是一个严格限于某种特定类型应用的框架或者是语言. 它其实是一种范式, 你可以在任何事件驱动的软件中实践它.</p>

    </div>
    <footer class="article-footer"><a class="article-share-link" data-url="http://blog-next.chenlei.me/2016/12/03/lets-learn-rxjs/" data-id="ckuih67s20023abnmbfop06bt">分享</a><ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/rxjs/" rel="tag">rxjs</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li></ul>
    </footer>
  </div>
<nav id="article-nav"><a class="article-nav-link-wrap" id="article-nav-newer" href="/2017/02/23/Golang-auto-reload-tool-for-Nodejs-Developer/"><strong class="article-nav-caption">Newer</strong>
    <div class="article-nav-title">Gor - Golang auto reload tool for Nodejs Developer
    </div></a>
</nav>
</article>
          </section>
<aside class="http" id="sidebar">

  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/React/" rel="tag">React</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/chrome/" rel="tag">chrome</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/es6/" rel="tag">es6</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/golang/" rel="tag">golang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js/" rel="tag">js</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-fix/" rel="tag">js-fix</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-trick/" rel="tag">js-trick</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/js-utils/" rel="tag">js-utils</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/json-iterator/" rel="tag">json-iterator</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/meltdown/" rel="tag">meltdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/pug/" rel="tag">pug</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/rxjs/" rel="tag">rxjs</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/vue/" rel="tag">vue</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%B9%B4%E8%AE%B0/" rel="tag">年记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/" rel="tag">纯函数</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag">翻译</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9A%8F%E7%AC%94/" rel="tag">随笔</a></li></ul>
    </div>
  </div>


  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/React/" style="font-size: 15px;">React</a> <a href="/tags/chrome/" style="font-size: 10px;">chrome</a> <a href="/tags/es6/" style="font-size: 10px;">es6</a> <a href="/tags/golang/" style="font-size: 15px;">golang</a> <a href="/tags/js/" style="font-size: 10px;">js</a> <a href="/tags/js-fix/" style="font-size: 10px;">js-fix</a> <a href="/tags/js-trick/" style="font-size: 10px;">js-trick</a> <a href="/tags/js-utils/" style="font-size: 10px;">js-utils</a> <a href="/tags/json-iterator/" style="font-size: 10px;">json-iterator</a> <a href="/tags/meltdown/" style="font-size: 10px;">meltdown</a> <a href="/tags/pug/" style="font-size: 10px;">pug</a> <a href="/tags/rxjs/" style="font-size: 10px;">rxjs</a> <a href="/tags/vue/" style="font-size: 10px;">vue</a> <a href="/tags/%E5%B9%B4%E8%AE%B0/" style="font-size: 10px;">年记</a> <a href="/tags/%E7%BA%AF%E5%87%BD%E6%95%B0/" style="font-size: 10px;">纯函数</a> <a href="/tags/%E7%BF%BB%E8%AF%91/" style="font-size: 10px;">翻译</a> <a href="/tags/%E9%9A%8F%E7%AC%94/" style="font-size: 20px;">随笔</a>
    </div>
  </div>

  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">三月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">二月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">一月 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/10/">十月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">二月 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">十二月 2016</a></li></ul>
    </div>
  </div>


  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/10/08/test-tag-react17/">测试 React17 标签</a>
          </li>
        
          <li>
            <a href="/2018/03/04/simple-mac-app-compiled-with-gcc/">使用 GCC 编译简单的 Mac App</a>
          </li>
        
          <li>
            <a href="/2018/02/11/barkjs/you-might-not-need-vue-sfc/">你可能不需要 *.vue</a>
          </li>
        
          <li>
            <a href="/2018/02/03/24-years-old/">轮回</a>
          </li>
        
          <li>
            <a href="/2018/01/21/left-displacement/">一路向西</a>
          </li>
        
      </ul>
    </div>
  </div>

</aside>
        </div>
<footer id="footer">
  <div class="outer">
    <div class="inner" id="footer-info">&copy;2021&nbsp;Xeon&nbsp;运行于&nbsp;<a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
      </div>
<div id="mobile-nav"><a class="mobile-nav-link" href="/">首页</a><a class="mobile-nav-link" href="/archives">归档</a><a class="mobile-nav-link" href="/cv">简历</a>
</div><script src="//cdn.bootcss.com/jquery/2.0.3/jquery.min.js"></script>
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

<script src="/fancybox/jquery.fancybox.pack.js"></script>

<script src="/js/script.js"></script>

    </div>
  </body>
</html>